<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Clicker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Clicker.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { useState, useEffect, useRef, useCallback } from 'react';
import ClickButton from './ClickButton';
import Stats from './Stats';

import { useSocket } from '../contexts/SocketContext';
/**
 * @typedef {Object} ClickerProps
 * @property {function} onUnlock - Function to call when unlocking content
 * @property {number} totalClicks - Total number of clicks
 * @property {number} flatClickBonus - Flat bonus applied to each click
 * @property {number} percentageClickBonus - Percentage bonus applied to each click
 * @property {number} bestCPS - Best clicks per second achieved
 */

/**
 * Clicker component for handling user clicks and displaying click information.
 * @param {ClickerProps} props - Component props
 * @returns {JSX.Element} Clicker component
 */
function Clicker({ onUnlock, totalClicks, flatClickBonus, percentageClickBonus, bestCPS: propBestCPS }) {
  const { socket, userId, username, cursors, setUsername } = useSocket();
  
  const [clientCPS, setClientCPS] = useState(0);
  const clicksRef = useRef([]);
  const [isSimulating, setIsSimulating] = useState(false);
  const cpsRef = useRef(0);

  const [isTimerEnabled, setIsTimerEnabled] = useState(true);
  const [isTimerRunning, setIsTimerRunning] = useState(false);
  const [timerDuration, setTimerDuration] = useState(10);
  const [timeLeft, setTimeLeft] = useState(timerDuration);
  const [timerClicks, setTimerClicks] = useState(0);
  const [records, setRecords] = useState([]);

  const timeLeftRef = useRef(timerDuration);
  const timerStartTimeRef = useRef(0);

  const [listeningForKey, setListeningForKey] = useState(false);
  const [selectedKey, setSelectedKey] = useState(null);
  const [keyPressed, setKeyPressed] = useState(false); // Add state to track key press

  const calculateClickValue = useCallback(() => {
    const baseClickValue = 1;
    const bonusClickValue = flatClickBonus;
    const multipliedClickValue = (baseClickValue + bonusClickValue) * percentageClickBonus;
    return Math.round(multipliedClickValue);
  }, [flatClickBonus, percentageClickBonus]);

  const startTimer = useCallback(() => {
    setIsTimerRunning(true);
    setTimeLeft(timerDuration);
    timeLeftRef.current = timerDuration;
    timerStartTimeRef.current = Date.now();
    setTimerClicks(0);
  }, [timerDuration]);

  const stopTimer = useCallback(() => {
    setIsTimerRunning(false);
    const actualDuration = (Date.now() - timerStartTimeRef.current) / 1000;
    const averageCPS = timerClicks / actualDuration;
    setRecords(prevRecords => [...prevRecords, { clicks: timerClicks, averageCPS, duration: actualDuration }]);
  }, [timerClicks]);

  const resetTimer = () => {
    setIsTimerRunning(false);
    setTimeLeft(timerDuration);
    timeLeftRef.current = timerDuration;
    setTimerClicks(0);
  };

  const toggleTimerEnable = () => {
    setIsTimerEnabled(!isTimerEnabled);
    if (isTimerRunning) {
      stopTimer();
    }
  };

  const processClick = useCallback((clickValue) => {
    socket.emit('incrementCount', clickValue);
    const now = Date.now();
    clicksRef.current.push(now);
    const recentClicks = clicksRef.current.filter(click => now - click &lt; 1000);
    cpsRef.current = recentClicks.length;
    const newTotalClicks = totalClicks + clickValue;
    onUnlock(newTotalClicks, Math.max(clientCPS, propBestCPS));

    if (isTimerRunning) {
      setTimerClicks(prevClicks => prevClicks + 1);
      const elapsedTime = (now - timerStartTimeRef.current) / 1000;
      const remainingTime = Math.max(0, timerDuration - elapsedTime);
      timeLeftRef.current = remainingTime;
      setTimeLeft(Math.ceil(remainingTime));

      if (remainingTime &lt;= 0) {
        stopTimer();
      }
    }
  }, [totalClicks, onUnlock, clientCPS, propBestCPS, isTimerRunning, timerDuration, stopTimer]);

  const handleClick = useCallback(() => {
    const clickValue = calculateClickValue();
    processClick(clickValue);
    if (isTimerEnabled &amp;&amp; !isTimerRunning) {
      startTimer();
    }
  }, [calculateClickValue, processClick, isTimerEnabled, isTimerRunning, startTimer]);

  useEffect(() => {
    let simulationInterval;
    if (isSimulating) {
      simulationInterval = setInterval(() => {
        handleClick();
      }, 5);
    }

    const intervalId = setInterval(() => {
      const now = Date.now();
      const recentClicks = clicksRef.current.filter(click => now - click &lt; 1000);
      clicksRef.current = recentClicks;
      const instantaneousCPS = recentClicks.length;
      cpsRef.current = instantaneousCPS;
      setClientCPS(cpsRef.current);

      if (cpsRef.current > propBestCPS) {
        onUnlock(totalClicks, cpsRef.current);
      }

      if (isTimerRunning) {
        const elapsedTime = (now - timerStartTimeRef.current) / 1000;
        const remainingTime = Math.max(0, timerDuration - elapsedTime);
        timeLeftRef.current = remainingTime;
        setTimeLeft(Math.ceil(remainingTime));

        if (remainingTime &lt;= 0) {
          stopTimer();
        }
      }
    }, 5);

    return () => {
      clearInterval(intervalId);
      if (simulationInterval) clearInterval(simulationInterval);
    };
  }, [handleClick, isSimulating, onUnlock, propBestCPS, totalClicks, isTimerRunning, timerDuration, stopTimer]);

  useEffect(() => {
    const handleKeyPress = (event) => {
      if (event.key === selectedKey &amp;&amp; !keyPressed) {
        event.preventDefault(); // Prevent default behavior
        setKeyPressed(true);
      }
    };

    const handleKeyRelease = (event) => {
      if (event.key === selectedKey &amp;&amp; keyPressed) {
        setKeyPressed(false);
        handleClick();
      }
    };

    if (selectedKey) {
      window.addEventListener('keydown', handleKeyPress);
      window.addEventListener('keyup', handleKeyRelease);
    }

    return () => {
      window.removeEventListener('keydown', handleKeyPress);
      window.removeEventListener('keyup', handleKeyRelease);
    };
  }, [selectedKey, handleClick, keyPressed]);

  const toggleSimulation = () => {
    setIsSimulating(!isSimulating);
  };

  const startListeningForKey = () => {
    setListeningForKey(true);
  };

  const handleKeySelection = (event) => {
    if (listeningForKey) {
      setSelectedKey(event.key);
      setListeningForKey(false);
    }
  };

  useEffect(() => {
    if (listeningForKey) {
      window.addEventListener('keydown', handleKeySelection);
    }

    return () => {
      window.removeEventListener('keydown', handleKeySelection);
    };
  }, [listeningForKey]);

  return (
    &lt;div>
      &lt;ClickButton onClick={handleClick} />
      &lt;Stats cps={clientCPS} bestCps={propBestCPS} totalClicks={totalClicks} />
      &lt;button onClick={toggleSimulation}>
        {isSimulating ? 'Stop Simulation' : 'Start Simulation'}
      &lt;/button>
      {/* Timer controls */}
      &lt;div>
        &lt;label>
          &lt;input 
            type="checkbox" 
            checked={isTimerEnabled}
            onChange={toggleTimerEnable}
          />
          Enable Timer
        &lt;/label>
        &lt;input 
          type="number" 
          value={timerDuration} 
          onChange={(e) => setTimerDuration(Number(e.target.value))}
          min="1"
        />
        &lt;button onClick={resetTimer}>
          Reset Timer
        &lt;/button>
        {isTimerEnabled &amp;&amp; (isTimerRunning ? (
          &lt;p>Time left: {timeLeft}s&lt;/p>
        ) : (
          &lt;p>Click to start timer&lt;/p>
        ))}
      &lt;/div>

      {/* Key selection */}
      &lt;div>
        &lt;button onClick={startListeningForKey}>
          {listeningForKey ? 'Press any key...' : 'Listen for key'}
        &lt;/button>
        {selectedKey &amp;&amp; !listeningForKey &amp;&amp; (
          &lt;p>Selected key: {selectedKey}&lt;/p>
        )}
      &lt;/div>

      {/* Display records */}
      &lt;div>
        &lt;h3>Records:&lt;/h3>
        &lt;ul>
          {records.map((record, index) => (
            &lt;li key={index}>
              Clicks: {record.clicks}, 
              Avg CPS: {record.averageCPS.toFixed(2)}, 
              Duration: {record.duration}s
            &lt;/li>
          ))}
        &lt;/ul>
      &lt;/div>
    &lt;/div>
  );
}

export default Clicker;

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#Clicker">Clicker</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Mar 01 2025 21:49:03 GMT+0300 (Moscow Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
